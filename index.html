<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fun Geo Dash Game</title>
<style>
  body {
    margin: 0;
    background: black;
    overflow: hidden;
    font-family: monospace, monospace;
    color: white;
    user-select: none;
  }
  h1 {
    text-align: center;
    margin: 10px 0;
    color: cyan;
    text-shadow: 0 0 8px cyan;
  }
  canvas {
    display: block;
    margin: 0 auto;
    background: black;
    border: 5px solid cyan;
  }
  #scoreboard {
    position: absolute;
    top: 50px;
    left: 10px;
    font-size: 18px;
    z-index: 10;
  }
  .mobile-controls {
    display: none;
    position: absolute;
    bottom: 20px;
    width: 100%;
    text-align: center;
  }
  .mobile-controls button {
    font-size: 24px;
    padding: 10px 20px;
    background: cyan;
    border: none;
    border-radius: 8px;
  }
  @media (max-width: 768px) {
    .mobile-controls {
      display: block;
    }
  }
</style>
</head>
<body>
  <h1>Fun Geo Dash Game</h1>
  <div id="scoreboard">
    Score: <span id="score">0</span> | High Socre: <span id="highscore">0</span>
  </div>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div class="mobile-controls">
    <button onclick="jump()">⬆️</button>
  </div>
<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  let score = 0;
  let highscore = localStorage.getItem("geoHighScore") || 0;
  document.getElementById("highscore").textContent = highscore;

  const BLOCK_WIDTH = 30;
  const FLOOR_Y = canvas.height - 5;

  const player = {
    x: 50,
    y: FLOOR_Y - 30,
    width: 30,
    height: 30,
    color: "cyan",
    velocityY: 0,
    gravity: 0.7,
    onGround: false,
    jumpTime: 0,
    jumpDuration: 30,
    jumpHeight: BLOCK_WIDTH * 3,
    jumpForward: BLOCK_WIDTH * 3,
    jumping: false,
    startX: 50
  };

  let blocks = [];
  let frameCount = 0;

  let nextBlockSpawnFrame = 0;

  function getGameSpeed() {
    if(score < 100) return 2;
    if(score >= 100 && score < 200) {
      return 2 + ((score - 100) / 100) * 2;
    }
    return 4 + (score - 200) * 0.02;
  }

  function generatePinkBlock() {
    let heightOptions;
    if(score < 100) {
      heightOptions = [BLOCK_WIDTH, BLOCK_WIDTH*2];
    } else {
      heightOptions = [BLOCK_WIDTH, BLOCK_WIDTH*2, BLOCK_WIDTH*3];
    }
    const heightBlocks = heightOptions[Math.floor(Math.random() * heightOptions.length)];
    const height = heightBlocks;
    const blockX = canvas.width;

    blocks.push({
      x: blockX,
      y: FLOOR_Y - height,
      width: BLOCK_WIDTH,
      height: height,
      color: "pink",
      type: "obstacle"
    });

    if (heightBlocks === BLOCK_WIDTH*3) {
      blocks.push({
        x: blockX - BLOCK_WIDTH,
        y: FLOOR_Y - BLOCK_WIDTH*2,
        width: BLOCK_WIDTH,
        height: BLOCK_WIDTH,
        color: "cyan",
        type: "platform"
      });
    } else if (heightBlocks === BLOCK_WIDTH*2) {
      blocks.push({
        x: blockX - BLOCK_WIDTH,
        y: FLOOR_Y - BLOCK_WIDTH,
        width: BLOCK_WIDTH,
        height: BLOCK_WIDTH,
        color: "cyan",
        type: "platform"
      });
    }
  }

  function updateBlocks() {
    const gameSpeed = getGameSpeed();

    blocks.forEach(b => b.x -= gameSpeed);
    blocks = blocks.filter(b => b.x + b.width > 0);

    blocks.forEach(b => {
      if (!b.passed && b.x + b.width < player.x) {
        b.passed = true;
        score++;
        document.getElementById("score").textContent = score;
      }
    });

    frameCount++;

    if (frameCount >= nextBlockSpawnFrame) {
      generatePinkBlock();
      nextBlockSpawnFrame = frameCount + 120 + Math.floor(Math.random() * 11);
    }
  }

  function jump() {
    if (!player.jumping && player.onGround) {
      player.jumping = true;
      player.jumpTime = 0;
      player.startX = player.x;
      player.onGround = false;
      player.velocityY = 0;
    }
  }

  function updatePlayer() {
    if (player.jumping) {
      player.jumpTime++;
      const t = player.jumpTime / player.jumpDuration;
      if (t > 1) {
        player.jumping = false;
        player.velocityY = 0;
        player.y = FLOOR_Y - player.height;
        player.onGround = true;
        player.x = player.startX + player.jumpForward;
      } else {
        player.y = FLOOR_Y - player.height - 4 * player.jumpHeight * t * (1 - t);
        player.x = player.startX + player.jumpForward * t;
      }
    } else {
      player.velocityY += player.gravity;
      player.y += player.velocityY;

      if (player.y + player.height >= FLOOR_Y) {
        player.y = FLOOR_Y - player.height;
        player.velocityY = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }

      if (player.velocityY >= 0) {
        for (let b of blocks) {
          if (b.type === "platform") {
            const playerBottom = player.y + player.height;
            const blockTop = b.y;
            const withinX = player.x + player.width > b.x && player.x < b.x + b.width;
            const closeY = playerBottom <= blockTop + player.velocityY && playerBottom + player.velocityY >= blockTop;
            if (withinX && closeY) {
              player.y = blockTop - player.height;
              player.velocityY = 0;
              player.onGround = true;
            }
          }
        }
      }
    }

    for (let b of blocks) {
      if (b.type === "obstacle") {
        if (
          player.x < b.x + b.width &&
          player.x + player.width > b.x &&
          player.y < b.y + b.height &&
          player.y + player.height > b.y
        ) {
          resetGame();
          break;
        }
      }
    }
  }

  function resetGame() {
    highscore = Math.max(highscore, score);
    localStorage.setItem("geoHighScore", highscore);
    document.getElementById("highscore").textContent = highscore;
    score = 0;
    document.getElementById("score").textContent = score;
    blocks = [];
    player.y = FLOOR_Y - player.height;
    player.velocityY = 0;
    player.jumping = false;
    frameCount = 0;
    nextBlockSpawnFrame = 0;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "cyan";
    ctx.fillRect(0, FLOOR_Y, canvas.width, 5);

    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    blocks.forEach(b => {
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x, b.y, b.width, b.height);
      ctx.strokeStyle = b.type === "obstacle" ? "purple" : "cyan";
      ctx.lineWidth = 2;
      ctx.strokeRect(b.x, b.y, b.width, b.height);
    });
  }

  function gameLoop() {
    updatePlayer();
    updateBlocks();
    draw();
    requestAnimationFrame(gameLoop);
  }

  document.addEventListener("keydown", e => {
    if (["Space", "ArrowUp", "KeyW"].includes(e.code)) jump();
  });

  window.jump = jump;
  gameLoop();
</script>
</body>
</html>
